
import { Router } from 'express';
import { getLeadBySlug, getLeadById, updateLead, getAgentBySlug } from '../services/db';
import { hashPassword, verifyPassword, generateToken, verifyToken, generateResetToken, verifyResetToken } from '../services/auth';

const router = Router();

// LOGIN
router.post('/login', async (req, res) => {
    try {
        const { slug, password } = req.body;

        console.log(`[Auth] Login attempt for slug: ${slug}`);

        if (!slug || !password) {
            return res.status(400).json({ error: 'Missing slug or password' });
        }

        // 1. Find Agent (Auth lookup - ignores published status)
        const { data: agent, error } = await getAgentBySlug(slug);

        if (error || !agent) {
            console.warn(`[Auth] Login failed: Agent not found for slug '${slug}'`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // 2. Verify Password
        let isValid = false;

        if (agent.password_hash) {
            isValid = await verifyPassword(password, agent.password_hash);
        } else {
            // Lazy Seeding: If no hash, check if they are using the default "welcome123"
            // If so, grant access AND save the hash for future.
            console.log(`[Auth] Agent ${slug} has no password hash. Checking default credentials...`);

            // Use environment variable for default password (set in .env)
            // Use environment variable for default password (set in .env)
            const defaultPassword = process.env.DEFAULT_AGENT_PASSWORD || 'welcome123';

            if (password === defaultPassword) {
                console.log(`[Auth] Default password accepted. Migrating agent ${slug} to secure hash...`);
                const newHash = await hashPassword(password);

                // Save to DB in background (await to be safe)
                await updateLead(agent.id, { password_hash: newHash });
                isValid = true;
            } else {
                console.warn(`[Auth] Agent ${slug} has no hash and provided wrong default password.`);
                isValid = false;
            }
        }

        if (!isValid) {
            console.warn(`[Auth] Login failed: Password mismatch for ${slug}`);
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        console.log(`[Auth] Login success for ${slug}`);

        // Start Trial if not already started
        if (!agent.trial_started_at) {
            console.log(`[Auth] Starting trial for ${slug} on first login.`);
            const now = new Date().toISOString();
            await updateLead(agent.id, { trial_started_at: now });
            // Update local object so token/claims (if any) reflect it, or irrelevant
            agent.trial_started_at = now;
        }

        // 3. Generate Token
        const token = generateToken(agent.id, agent.website_slug);

        // 4. Return
        res.json({ token, agent: { id: agent.id, name: agent.full_name, slug: agent.website_slug } });

    } catch (err) {
        console.error('[Auth] Login error:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// FORGOT PASSWORD
router.post('/forgot-password', async (req, res) => {
    try {
        const { slug } = req.body;

        if (!slug) {
            return res.status(400).json({ error: 'Slug is required' });
        }

        const { data: agent, error } = await getAgentBySlug(slug);

        if (error || !agent) {
            // Don't reveal if agent exists
            return res.json({ success: true, message: 'If an account exists, a reset email has been sent.' });
        }

        if (!agent.primary_email) {
            return res.json({ success: true, message: 'If an account exists, a reset email has been sent.' });
        }

        // Generate reset token
        const resetToken = generateResetToken(agent.id, agent.website_slug);
        const CLIENT_URL = process.env.CLIENT_URL || 'http://localhost:5173';
        const resetUrl = `${CLIENT_URL}/w/${agent.website_slug}/admin/reset-password?token=${resetToken}`;

        // Send email
        const { sendPasswordResetEmail } = await import('../services/email');
        const result = await sendPasswordResetEmail({
            agentName: agent.full_name,
            agentEmail: agent.primary_email,
            resetUrl
        });

        if (!result.success) {
            console.error('[Auth] Failed to send reset email:', result.error);
        }

        res.json({ success: true, message: 'If an account exists, a reset email has been sent.' });

    } catch (err) {
        console.error('[Auth] Forgot password error:', err);
        res.status(500).json({ error: 'Failed to process request' });
    }
});

// RESET PASSWORD (with token)
router.post('/reset-password', async (req, res) => {
    try {
        const { token, newPassword } = req.body;

        if (!token || !newPassword) {
            return res.status(400).json({ error: 'Token and new password are required' });
        }

        if (newPassword.length < 6) {
            return res.status(400).json({ error: 'Password must be at least 6 characters' });
        }

        const payload = verifyResetToken(token);

        if (!payload) {
            return res.status(400).json({ error: 'Invalid or expired reset link' });
        }

        // Hash new password
        const hashedPassword = await hashPassword(newPassword);

        // Update DB
        const result = await updateLead(payload.agentId, { password_hash: hashedPassword } as any);

        if (!result.success) {
            throw new Error(result.error);
        }

        res.json({ success: true, message: 'Password updated successfully', slug: payload.slug });

    } catch (err) {
        console.error('[Auth] Reset password error:', err);
        res.status(500).json({ error: 'Failed to reset password' });
    }
});

// CHANGE PASSWORD
router.post('/change-password', async (req, res) => {
    try {
        const authHeader = req.headers.authorization;
        const { newPassword } = req.body;

        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        if (!newPassword || newPassword.length < 6) {
            return res.status(400).json({ error: 'Password must be at least 6 characters' });
        }

        const token = authHeader.split(' ')[1];
        const payload = verifyToken(token);

        if (!payload || !payload.agentId) {
            return res.status(401).json({ error: 'Invalid token' });
        }

        // Hash new password
        const hashedPassword = await hashPassword(newPassword);

        // Update DB
        const result = await updateLead(payload.agentId, { password_hash: hashedPassword } as any); // Cast because DB types might not include password_hash yet in TS definition if we didn't update types file

        if (!result.success) {
            throw new Error(result.error);
        }

        res.json({ success: true, message: 'Password updated successfully' });

    } catch (err) {
        console.error('[Auth] Change password error:', err);
        res.status(500).json({ error: 'Failed to update password' });
    }
});

// VERIFY TOKEN (Optional: to check if session is valid on load)
router.get('/me', async (req, res) => {
    try {
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        const token = authHeader.split(' ')[1];
        const payload = verifyToken(token);
        if (!payload) return res.status(401).json({ error: 'Invalid token' });

        res.json({ valid: true, agentId: payload.agentId });
    } catch (err) {
        res.status(401).json({ error: 'Invalid token' });
    }
});

export default router;
